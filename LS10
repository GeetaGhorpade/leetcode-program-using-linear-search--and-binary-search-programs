Share

GG
You said:
10 different linear search programs in leetcode in c++
ChatGPT said:
Linear search is a straightforward algorithm that involves traversing a data structure sequentially to find a target value. While many problems can be optimized with more advanced algorithms, some LeetCode problems can be approached using linear search. Below are 10 such problems, along with brief descriptions and links to their solutions:

Two Sum: Find two numbers in an array that add up to a specific target.

Problem: 
GITHUB
Solution: 
GITHUB
Find Peak Element: Identify an element in an array that is greater than its neighbors.

Problem: 
LEETCODE
Solution: 
LEETCODE
Find the Index of the First Occurrence in a String: Locate the first occurrence of a substring within a string.

Problem: 
LEETCODE
Solution: 
GITHUB
Kth Missing Positive Number: Determine the k-th missing positive integer from a sorted array.

Problem: 
LEETCODE
Solution: 
GITHUB
Single Element in a Sorted Array: Find the element that appears only once in a sorted array where all other elements appear twice.

Problem: 
LEETCODE
Solution: 
GITHUB
Find First and Last Position of Element in Sorted Array: Locate the starting and ending positions of a given target value in a sorted array.

Problem: 
LEETCODE
Solution: 
GITHUB
Search in Rotated Sorted Array: Search for a target value in a rotated sorted array.

Problem: 
LEETCODE
Solution: 
GITHUB
Sqrt(x): Compute the square root of a non-negative integer, rounded down to the nearest integer.

Problem: 
LEETCODE
Solution: 
GITHUB
Binary Search: Implement the binary search algorithm to find a target value in a sorted array.

Problem: 
LEETCODE
Solution: 
GITHUB
Container With Most Water: Determine the maximum amount of water that can be contained between two lines in a given array.

Problem: 
GITHUB
Solution: 
GITHUB
For comprehensive C++ solutions to these and other problems, you can refer to the following GitHub repositories:

fengvyi's LeetCode Solutions
kamyu104's LeetCode Solutions
These repositories offer a wide range of problem solutions implemented in C++.


Sources








You said:
with thier outputs
Reasoned for 9 seconds
Below are 10 standalone C++ programs that each solve a LeetCode–style problem using a linear (or brute-force) search approach. Each snippet includes a sample input (hard‐coded in main) along with comments showing the expected output.

1. Two Sum (Linear Search Approach)
This program searches for two numbers that add up to a given target by iterating over the array twice (brute force).

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    int n = nums.size();
    bool found = false;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (nums[i] + nums[j] == target) {
                cout << "Indices: " << i << ", " << j << endl;
                found = true;
                break;
            }
        }
        if(found) break;
    }
    
    if (!found) {
        cout << "No two sum solution found." << endl;
    }
    
    return 0;
}
Sample Output:

makefile
Copy
Edit
Indices: 0, 1
2. Find Peak Element
A linear scan finds the first “peak” where an element is greater than its neighbors.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {1, 3, 20, 4, 1, 0};
    int n = nums.size();
    int peakIndex = -1;
    
    for (int i = 0; i < n; i++) {
        bool leftOk = (i == 0) || (nums[i] > nums[i - 1]);
        bool rightOk = (i == n - 1) || (nums[i] > nums[i + 1]);
        if (leftOk && rightOk) {
            peakIndex = i;
            break;
        }
    }
    
    cout << "Peak index: " << peakIndex << endl;
    return 0;
}
Sample Output:

perl
Copy
Edit
Peak index: 2
3. First Occurrence of a Substring (Naive Search)
A straightforward implementation of finding the first occurrence of a substring.

cpp
Copy
Edit
#include <iostream>
#include <string>
using namespace std;

int main() {
    string haystack = "hello";
    string needle = "ll";
    int n = haystack.size(), m = needle.size();
    int index = -1;
    
    for (int i = 0; i <= n - m; i++) {
        int j = 0;
        while (j < m && haystack[i + j] == needle[j]) {
            j++;
        }
        if (j == m) {
            index = i;
            break;
        }
    }
    
    cout << "First occurrence at index: " << index << endl;
    return 0;
}
Sample Output:

perl
Copy
Edit
First occurrence at index: 2
4. Kth Missing Positive Number
This program finds the kth missing positive integer in a sorted array using linear scanning.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {2, 3, 4, 7, 11};
    int k = 5;
    int missing = 0, current = 1, i = 0;
    
    while (missing < k) {
        if (i < nums.size() && nums[i] == current) {
            i++;
        } else {
            missing++;
            if(missing == k) {
                cout << "The " << k << "th missing number is: " << current << endl;
                break;
            }
        }
        current++;
    }
    
    return 0;
}
Sample Output:

csharp
Copy
Edit
The 5th missing number is: 9
5. Single Element in a Sorted Array
Find the element that appears only once in an array where every other element appears twice.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {1, 1, 2, 3, 3, 4, 4, 8, 8};
    int n = nums.size();
    int single = -1;
    
    // Using linear search since array is sorted
    for (int i = 0; i < n; i += 2) {
        if (i == n - 1 || nums[i] != nums[i + 1]) {
            single = nums[i];
            break;
        }
    }
    
    cout << "Single element: " << single << endl;
    return 0;
}
Sample Output:

vbnet
Copy
Edit
Single element: 2
6. Find First and Last Position of Element
A linear approach to locate the first and last indices of a target element.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {5, 7, 7, 8, 8, 10};
    int target = 8;
    int first = -1, last = -1;
    
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == target) {
            if (first == -1) first = i;
            last = i;
        }
    }
    
    cout << "First position: " << first << ", Last position: " << last << endl;
    return 0;
}
Sample Output:

arduino
Copy
Edit
First position: 3, Last position: 4
7. Search in Rotated Sorted Array
Even though a binary search solution is more efficient, here we use a simple linear scan.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {4, 5, 6, 7, 0, 1, 2};
    int target = 0;
    int index = -1;
    
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == target) {
            index = i;
            break;
        }
    }
    
    cout << "Target found at index: " << index << endl;
    return 0;
}
Sample Output:

pgsql
Copy
Edit
Target found at index: 4
8. Sqrt(x) (Linear Search Approach)
Computes the integer square root by iterating until the next square exceeds x.

cpp
Copy
Edit
#include <iostream>
using namespace std;

int main() {
    int x = 8;
    int i = 0;
    
    while (i * i <= x) {
        i++;
    }
    
    cout << "sqrt(" << x << ") = " << i - 1 << endl;
    return 0;
}
Sample Output:

cpp
Copy
Edit
sqrt(8) = 2
9. Linear Search in a Sorted Array
Even for sorted arrays, a linear search can be used to find an element.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    int target = 4;
    int index = -1;
    
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == target) {
            index = i;
            break;
        }
    }
    
    cout << "Element " << target << " found at index: " << index << endl;
    return 0;
}
Sample Output:

pgsql
Copy
Edit
Element 4 found at index: 3
10. Container With Most Water (Brute Force)
Uses a double loop (which is O(n²)) to check every pair of lines to compute the maximum water container.

cpp
Copy
Edit
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> height = {1, 8, 6, 2, 5, 4, 8, 3, 7};
    int n = height.size();
    int maxArea = 0;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int currentArea = min(height[i], height[j]) * (j - i);
            maxArea = max(maxArea, currentArea);
        }
    }
    
    cout << "Maximum water container area: " << maxArea << endl;
    return 0;
}
Sample Output:

yaml
Copy
Edit
Maximum water container area: 49
Each of these programs uses a linear or brute-force approach to solve the given problem and prints a result based on the hardcoded input values. You can compile and run these on your local machine or an online C++ compiler to see the outputs in action.







You said:
10 different linear search programs in DSA using c++ in leetcode
Reasoned about DSA linear search programs in C++ for 19 seconds
Below are 10 standalone C++ programs that solve common DSA problems using a linear (or brute‐force) search approach. Each program is self-contained with hardcoded sample inputs and comments indicating the expected output. These examples mimic LeetCode–style challenges that can be solved via linear scanning.

1. Basic Linear Search in an Unsorted Array
Searches for a target element in an unsorted array and prints its index.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {4, 2, 7, 1, 9};
    int target = 7;
    int index = -1;
    
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            index = i;
            break;
        }
    }
    
    cout << "Element " << target << " found at index: " << index << endl;
    return 0;
}
Sample Output:

pgsql
Copy
Edit
Element 7 found at index: 2
2. Find the First Occurrence of a Target
Finds the first occurrence of a given target in a sorted array.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 2, 3, 4};
    int target = 2;
    int firstIndex = -1;
    
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            firstIndex = i;
            break;
        }
    }
    
    cout << "First occurrence of " << target << " is at index: " << firstIndex << endl;
    return 0;
}
Sample Output:

pgsql
Copy
Edit
First occurrence of 2 is at index: 1
3. Find the Last Occurrence of a Target
Finds the last occurrence of a target element in an array by scanning through all elements.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 2, 3, 4};
    int target = 2;
    int lastIndex = -1;
    
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            lastIndex = i;
        }
    }
    
    cout << "Last occurrence of " << target << " is at index: " << lastIndex << endl;
    return 0;
}
Sample Output:

pgsql
Copy
Edit
Last occurrence of 2 is at index: 2
4. Count the Frequency of a Target Element
Counts how many times a given target appears in the array.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 2, 3, 2, 4};
    int target = 2;
    int count = 0;
    
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            count++;
        }
    }
    
    cout << "Frequency of " << target << " is: " << count << endl;
    return 0;
}
Sample Output:

csharp
Copy
Edit
Frequency of 2 is: 3
5. Find the Minimum Element in an Unsorted Array
Uses linear search to determine the smallest value in an array.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {4, 2, 7, 1, 9};
    int minVal = arr[0];
    
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] < minVal) {
            minVal = arr[i];
        }
    }
    
    cout << "Minimum element is: " << minVal << endl;
    return 0;
}
Sample Output:

csharp
Copy
Edit
Minimum element is: 1
6. Find the Maximum Element in an Unsorted Array
Finds the largest element in the array by scanning through each element.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {4, 2, 7, 1, 9};
    int maxVal = arr[0];
    
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }
    
    cout << "Maximum element is: " << maxVal << endl;
    return 0;
}
Sample Output:

csharp
Copy
Edit
Maximum element is: 9
7. Check if an Array is Sorted
Determines if the given array is sorted in non-decreasing order.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    bool isSorted = true;
    
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] < arr[i - 1]) {
            isSorted = false;
            break;
        }
    }
    
    if (isSorted)
        cout << "Array is sorted." << endl;
    else
        cout << "Array is not sorted." << endl;
    
    return 0;
}
Sample Output:

python
Copy
Edit
Array is sorted.
8. Linear Search for a Character in a String
Searches for the first occurrence of a character within a string.

cpp
Copy
Edit
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s = "leetcode";
    char target = 'e';
    int index = -1;
    
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == target) {
            index = i;
            break;
        }
    }
    
    cout << "Character '" << target << "' found at index: " << index << endl;
    return 0;
}
Sample Output:

pgsql
Copy
Edit
Character 'e' found at index: 1
9. Naive Substring Search (Find First Occurrence)
Implements a basic linear search to locate the first occurrence of a substring within a string.

cpp
Copy
Edit
#include <iostream>
#include <string>
using namespace std;

int main() {
    string haystack = "hello world";
    string needle = "world";
    int index = -1;
    
    for (int i = 0; i <= haystack.size() - needle.size(); i++) {
        int j = 0;
        while (j < needle.size() && haystack[i + j] == needle[j])
            j++;
        if (j == needle.size()) {
            index = i;
            break;
        }
    }
    
    cout << "Substring found at index: " << index << endl;
    return 0;
}
Sample Output:

pgsql
Copy
Edit
Substring found at index: 6
10. Find the Pivot Index in a Rotated Sorted Array
Scans the array to detect where a sorted array has been rotated. The pivot is the index where an element is greater than its next element.

cpp
Copy
Edit
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {4, 5, 6, 7, 0, 1, 2};
    int pivot = -1;
    
    for (int i = 0; i < nums.size() - 1; i++) {
        if (nums[i] > nums[i + 1]) {
            pivot = i;
            break;
        }
    }
    
    if (pivot == -1)
        cout << "Array is not rotated." << endl;
    else
        cout << "Array is rotated at index: " << pivot << endl;
    
    return 0;
}
Sample Output:

pgsql
Copy
Edit
Array is rotated at index: 3
Each of these programs uses a linear search approach to solve a specific problem. You can compile and run these on your local machine or an online C++ compiler to observe the outputs.

1. Basic Linear Search in an ArraySearches for a target element in an unsorted array and prints its index.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {4, 2, 7, 1, 9};
    int target = 7;
    int index = -1;
    
    // Linear search for the target
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            index = i;
            break;
        }
    }
    
    cout << "Element " << target << " found at index: " << index << endl;
    // Expected output: Element 7 found at index: 2
    return 0;
}

2. Find the First Occurrence of a TargetFinds and prints the index of the first occurrence of a target element in an array.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 2, 3, 4};
    int target = 2;
    int firstIndex = -1;
    
    // Scan to find first occurrence
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            firstIndex = i;
            break;
        }
    }
    
    cout << "First occurrence of " << target << " is at index: " << firstIndex << endl;
    // Expected output: First occurrence of 2 is at index: 1
    return 0;
}

3. Find the Last Occurrence of a TargetScans the array completely to locate the last index where the target appears.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 2, 3, 4};
    int target = 2;
    int lastIndex = -1;
    
    // Continue scanning to update the last occurrence
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            lastIndex = i;
        }
    }
    
    cout << "Last occurrence of " << target << " is at index: " << lastIndex << endl;
    // Expected output: Last occurrence of 2 is at index: 2
    return 0;
}

4. Count the Frequency of an ElementCounts how many times a specific target element appears in the array.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 2, 3, 2, 4};
    int target = 2;
    int count = 0;
    
    // Count occurrences of target
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            count++;
        }
    }
    
    cout << "Frequency of " << target << " is: " << count << endl;
    // Expected output: Frequency of 2 is: 3
    return 0;
}

5. Find the Minimum Element in an ArrayUses linear search to determine the smallest value present in the array.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {4, 2, 7, 1, 9};
    int minVal = arr[0];
    
    // Compare each element to find the minimum
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] < minVal) {
            minVal = arr[i];
        }
    }
    
    cout << "Minimum element is: " << minVal << endl;
    // Expected output: Minimum element is: 1
    return 0;
}

6. Find the Maximum Element in an ArrayScans through the array to identify the largest element.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {4, 2, 7, 1, 9};
    int maxVal = arr[0];
    
    // Linear search to update the maximum value
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }
    
    cout << "Maximum element is: " << maxVal << endl;
    // Expected output: Maximum element is: 9
    return 0;
}

7. Check if an Array is SortedDetermines whether the array is sorted in non-decreasing order.

#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    bool isSorted = true;
    
    // Compare adjacent elements
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] < arr[i - 1]) {
            isSorted = false;
            break;
        }
    }
    
    if (isSorted)
        cout << "Array is sorted." << endl;
    else
        cout << "Array is not sorted." << endl;
    
    // Expected output: Array is sorted.
    return 0;
}

8. Linear Search for a Character in a StringSearches for the first occurrence of a character in a string.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s = "datastructures";
    char target = 's';
    int index = -1;
    
    // Linear search through the string
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == target) {
            index = i;
            break;
        }
    }
    
    cout << "Character '" << target << "' found at index: " << index << endl;
    // Expected output (first 's'): Character 's' found at index: 3
    return 0;
}

9. Naive Substring SearchImplements a basic linear search to find the first occurrence of a substring within a string.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string haystack = "hello world";
    string needle = "world";
    int index = -1;
    
    // Outer loop: each possible starting index
    for (int i = 0; i <= haystack.size() - needle.size(); i++) {
        int j = 0;
        // Check if the substring matches
        while (j < needle.size() && haystack[i + j] == needle[j])
            j++;
        if (j == needle.size()) {
            index = i;
            break;
        }
    }
    
    cout << "Substring found at index: " << index << endl;
    // Expected output: Substring found at index: 6
    return 0;
}

10. Find the Pivot Index in a Rotated Sorted ArrayIdentifies the pivot point 
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {4, 5, 6, 7, 0, 1, 2};
    int pivot = -1;
    
    // The pivot is where an element is greater than its next element.
    for (int i = 0; i < nums.size() - 1; i++) {
        if (nums[i] > nums[i + 1]) {
            pivot = i;
            break;
        }
    }
    
    if (pivot == -1)
        cout << "Array is not rotated." << endl;
    else
        cout << "Pivot (rotation point) is at index: " << pivot << endl;
    
    // Expected output: Pivot (rotation point) is at index: 3
    return 0;
}
